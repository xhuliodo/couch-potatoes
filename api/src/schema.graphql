type Movie {
  movieId(limit: Int = 10): ID! @id
  title: String!
  releaseYear: Int!
  imdbLink: String!
  posterUrl: String!
  genres: [Genre] @relation(name: "IN_GENRE", direction: "OUT")
  # this one is still in question whether or not i'm going to crawl for it
  # plot: String
}

type Genre {
  genreId: ID! @id
  name: String! @unique
}

# this one is still in question whether or not i'm going to crawl for it
# type Cast {

# }

type User {
  userId: ID! @id
  fullName: String
  # username: String @unique
  watchlist(limit: Int = 10): [Movie]!
    @relation(name: "WATCH_LATER", direction: "OUT")
}

type Mutation {
  likeMovie(userId: ID!, movieId: ID!): Movie
    @cypher(
      statement: "match (u:User{userId:$userId}), (m:Movie{movieId:$movieId}) merge (u)-[r:RATED]->(m) on create set r.rating=1 return m"
    )
  dislikeMovie(userId: ID!, movieId: ID!): Movie
    @cypher(
      statement: "match (u:User{userId:$userId}), (m:Movie{movieId:$movieId}) merge (u)-[r:RATED]->(m) on create set r.rating=0 return m"
    )
}

type Query {
  recommendPopularMoviesBasedOnGenre(
    genre_1: String!
    genre_2: String!
    genre_3: String!
    limit: Int!
  ): [Movie]!
    @cypher(
      statement: "match (m:Movie)-[:IN_GENRE]->(g:Genre) where g.name in [$genre_1,$genre_2,$genre_3] with  distinct(m) as movie match (:User)-[r:RATED]->(movie) with movie, count(r.rating) as howMany,avg(r.rating) as reviews return movie order by howMany desc, reviews desc limit toInteger($limit)"
    )
  recommendFromOtherUsers(
    userId: ID!
    minimumRatings: Int!
    peopleToCompare: Int!
    moviesToRecommend: Int = 25
  ): [Movie]!
    @cypher(
      statement: "match (u1:User {userId:$userId})-[r:RATED]->(m:Movie) with u1, avg(r.rating) AS u1_mean match (u1)-[r1:RATED]->(m:Movie)<-[r2:RATED]-(u2) with u1, u1_mean, u2, collect({r1: r1, r2: r2}) as ratings where size(ratings) > toInteger($minimumRatings) match (u2)-[r:RATED]->(m:Movie) with u1, u1_mean, u2, avg(r.rating) as u2_mean, ratings unwind ratings as r with sum( (r.r1.rating-u1_mean) * (r.r2.rating-u2_mean) ) as nom, sqrt( sum( (r.r1.rating - u1_mean)^2) * sum( (r.r2.rating - u2_mean) ^2)) as denom, u1, u2 where denom <> 0 with u1, u2, nom/denom as pearson order by pearson desc limit toInteger($peopleToCompare) match (u2)-[r:RATED]->(m:Movie) where not exists( (u1)-[:RATED]->(m) ) return m, sum( pearson * r.rating) as score order by score desc limit toInteger($moviesToRecommend)"
    )
  recommendToGroup(
    userId_1: ID!
    userId_2: ID!
    userId_3: ID
    minimumRatings: Int!
    peopleToCompare: Int!
    moviesToRecommend: Int = 25
  ): [Movie]!
    @cypher(
      statement: "match (u1:User)-[r:RATED]->(m:Movie) where u1.userId in [$userId_1,$userId_2] with u1, avg(r.rating) AS u1_mean match (u1)-[r1:RATED]->(m:Movie)<-[r2:RATED]-(u2) with u1, u1_mean, u2, collect({r1: r1, r2: r2}) as ratings where size(ratings) > toInteger($minimumRatings) match (u2)-[r:RATED]->(m:Movie) with u1, u1_mean, u2, avg(r.rating) as u2_mean, ratings unwind ratings as r with sum( (r.r1.rating-u1_mean) * (r.r2.rating-u2_mean) ) as nom, sqrt( sum( (r.r1.rating - u1_mean)^2) * sum( (r.r2.rating - u2_mean) ^2)) as denom, u1, u2 where denom <> 0 with u1, u2, nom/denom as pearson order by pearson desc limit toInteger($peopleToCompare) match (u2)-[r:RATED]->(m:Movie) where not exists( (u1)-[:RATED]->(m) ) return m, sum( pearson * r.rating) as score order by score desc limit toInteger($moviesToRecommend)"
    )
}
